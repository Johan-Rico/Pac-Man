class Ghost {
    field boolean color;
    field Map map;
    field PacMan pacman;
    field Score score;
    field int size;
    field int x, y, startX, startY;
    field int dir, nextDir;
    field int nextX, nextY;
    field int sprite, adition;
    field int speed, radius;
    field int previousDir; 
    field int leftLimit, rightLimit;
    field int spriteDelay, time, tm;
    field boolean isPursuer;
    field boolean isVulnerable;
    field boolean isOut;
    field int outX, outY;
    field int targetX, targetY;
    field boolean isChasing;

    constructor Ghost new(boolean c, Map m, PacMan p, int xi, int yi, boolean pursuer, int t) {
        let startX = xi;
        let startY = yi;
        let time = t;
        let tm = t;
        let color = c;
        let speed = 3;
        let radius = 7;
        let outX = 256;
        let outY = 108;
        let map = m;
        let pacman = p;
        let size = 12;
        let leftLimit = 1 + radius;
        let rightLimit = 510 - radius;
        let isPursuer = pursuer;
        let isVulnerable = false;

        let isChasing = true;
        
        do init();
        return this;
    }

    method void init() {
        var int i, ghostBottom;
        let x = startX;
        let y = startY;
        let tm = time;
        let spriteDelay = 0;
        let previousDir = 2;
        let dir = 2;
        let isOut = false;
        let nextDir = 2;
        return;
    }

    method void reset() {
        var int i, ghostBottom;
        let x = 256;
        let y = 144;
        let spriteDelay = 0;
        let previousDir = 2;
        let dir = 2;
        let isOut = false;
        let nextDir = 2;
        return;
    }

    method void changeColor(boolean c) {
        let color = c;
        return;
    }
    
    method void next() {
        var int oldX, oldY;
        var boolean didMove;
        
        do updateTarget();
        
        let oldX = x;
        let oldY = y;
        if (isVulnerable) {
            do Screen.setColor(color);
        } else {
            do Screen.setColor(~color);
        }
        let didMove = advance();
        do Screen.drawRectangle(oldX - radius, oldY - radius, oldX + radius, oldY + radius + 2);
        if (~(tm < 0)) {
            let tm = tm - 1;
            let x = oldX;
            let y = oldY;
            let dir = 2;
            let nextDir = 2;
            do draw();
            return;
        }
        if (~(isOut)) {
            if (~(x = outX)) {
                if ((outX - x) > 0) {
                    let x = oldX + speed;
                } else {
                    let x = oldX - speed;
                }
            } else {
                if (y = outY) {
                    let isOut = true;
                } else {
                    let y = oldY - speed;
                }
            }
        }
        do draw();
        return;
    }
    
    method void updateTarget() {
        var int pacmanX, pacmanY;
        
        let pacmanX = pacman.getX();
        let pacmanY = pacman.getY();
        
        if (~isPursuer) {
            if ((Random.rand() & 31) = 0) {
                let targetX = Random.rand() & 511;
                let targetY = (Random.rand() & 127) + 50;
            } else {
                if (isChasing) {
                    if ((Random.rand() & 7) = 0) {
                        do setNextDirRandom();
                    } else {
                        let targetX = pacmanX;
                        let targetY = pacmanY;
                    }
                } else {
                    if ((targetX = 0) | (targetY = 0) | ((Random.rand() & 31) = 0)) {
                        let targetX = Random.rand() & 511;
                        let targetY = (Random.rand() & 127) + 50;
                    }
                }
            }
        } else {
            if (isChasing) {
                let targetX = pacmanX;
                let targetY = pacmanY;

            } else {

                let targetX = (Random.rand() & 1) * 430 + 40;
                let targetY = (Random.rand() & 1) * 170 + 40;
            }
        }
        return;
    }

    method boolean advance() {
        var int nextX, nextY;
        if (isPursuer | isChasing) {
            if ((Random.rand() & 7) > 0) {
                do setNextDir();
            } else {
                do setNextDirRandom();
            }
        } else {
            if ((Random.rand() & 3) > 0) {
                do setNextDir();
            } else {
                do setNextDirRandom();
            }
        }
        
        let nextX = getNextX();
        let nextY = getNextY();
        
        if (checkWalls(nextX, nextY)) {
            do setNextDirRandom();
            return false;
        }
        
        if ((x = nextX) & (y = nextY)) {
            return false;
        }
        
        let x = nextX;
        let y = nextY;
        
        if (x < 9) {
            let x = rightLimit - 1;
        }
        if (x > rightLimit) {
            let x = leftLimit + 1;
        }
        
        return true;
    }
    
    method void setNextDir() {
        var int possibleDirs;
        var int bestDir;
        var int bestDist;
        var int testDist;
        var int testX, testY;
        
        let bestDist = 32767;
        let bestDir = dir;
        
        let possibleDirs = 0;
        
        let testX = x;
        let testY = y - speed;
        if (~(checkWalls(testX, testY))) {
            let possibleDirs = possibleDirs | 1;
        }
        
        let testX = x;
        let testY = y + speed;
        if (~(checkWalls(testX, testY))) {
            let possibleDirs = possibleDirs | 2;
        }
        
        let testX = x - speed;
        let testY = y;
        if (~(checkWalls(testX, testY))) {
            let possibleDirs = possibleDirs | 4; 
        }
        
        let testX = x + speed;
        let testY = y;
        if (~(checkWalls(testX, testY))) {
            let possibleDirs = possibleDirs | 8;
        }
        
        if (dir = 1) { let possibleDirs = possibleDirs & (~2); }
        if (dir = 2) { let possibleDirs = possibleDirs & (~1); }
        if (dir = 3) { let possibleDirs = possibleDirs & (~8); }
        if (dir = 4) { let possibleDirs = possibleDirs & (~4); }
        
        if (possibleDirs = 0) {
            if (dir = 1) { let possibleDirs = 2; }
            if (dir = 2) { let possibleDirs = 1; }
            if (dir = 3) { let possibleDirs = 8; }
            if (dir = 4) { let possibleDirs = 4; }
        }
        
        if ((possibleDirs & 1) > 0) {
            let testX = x;
            let testY = y - speed;
            let testDist = distanceSquared(testX, testY, targetX, targetY);
            if (testDist < bestDist) {
                let bestDist = testDist;
                let bestDir = 1;
            }
        }
        
        if ((possibleDirs & 2) > 0) {
            let testX = x;
            let testY = y + speed;
            let testDist = distanceSquared(testX, testY, targetX, targetY);
            if (testDist < bestDist) {
                let bestDist = testDist;
                let bestDir = 2;
            }
        }
        
        if ((possibleDirs & 4) > 0) {
            let testX = x - speed;
            let testY = y;
            let testDist = distanceSquared(testX, testY, targetX, targetY);
            if (testDist < bestDist) {
                let bestDist = testDist;
                let bestDir = 3;
            }
        }
        
        if ((possibleDirs & 8) > 0) {
            let testX = x + speed;
            let testY = y;
            let testDist = distanceSquared(testX, testY, targetX, targetY);
            if (testDist < bestDist) {
                let bestDist = testDist;
                let bestDir = 4;
            }
        }
        
        let dir = bestDir;
        return;
    }
    
    method int distanceSquared(int x1, int y1, int x2, int y2) {
        var int dx, dy;
        let dx = x2 - x1;
        let dy = y2 - y1;
        return (dx * dx) + (dy * dy);
    }
 
    method void setNextDirRandom() {
        var int i;
        let i = Random.rand() & 15;
        if (i < 4) {
            let dir = 1;
            return;
        }
        if (i < 8) {
            let dir = 2;
            return;
        }
        if (i < 12) {
            let dir = 3;
        }
        let dir = 4; 
        return;
    }

    method void setVulnerable(boolean v) {
        let isVulnerable = v;
        if (v) {
            let isChasing = false;
        } else {
            let isChasing = true;
        }
        return;
    }

    method boolean isVulnerable() {
        return isVulnerable;
    }
  
    method boolean checkWalls(int nextX, int nextY) {
        var int nextEndX, nextEndY;
        let nextEndX = nextX + size - 1;
        let nextEndY = nextY + size - 1;
        return (map.checkOverlapping(nextX, nextY, radius) | map.checkDoorOverlaping(nextX, nextY, radius));
    }

    method boolean checkPacmanCollision() {
        var int pacmanX, pacmanY;
        let pacmanX = pacman.getX();
        let pacmanY = pacman.getY();
        if ((Math.abs(x-pacmanX)<radius) & (Math.abs(y-pacmanY)<radius)) {
            return true;
        }
        return false;
    }
   
    method int getNextX() {
        var int nextX;
        let nextX = x;
        if (dir = 4) {
            let nextX = x + speed;
        }
        if (dir = 3) {
            let nextX = x - speed;
        }
        return nextX;
    }

    method int getNextY() {
        var int nextY;
        let nextY = y;
        if (dir = 2) {
            let nextY = y + speed;
        }
        if (dir = 1) {
            let nextY = y - speed;
        }
        if (nextY > 250) {
            let nextY = 12;
            do Screen.setColor(false);
            do Screen.drawRectangle(x, y, endX(), endY());
        }
        if (nextY < 12) {
            let nextY = 250;
            do Screen.setColor(false);
            do Screen.drawRectangle(x, y, endX(), endY());
        }
        return nextY;
    }
 
    method void clearGhost() {
        do Screen.setColor(~color);
        do Screen.drawRectangle(x - radius, y - radius, x + radius, y + radius + 2);
        return;
    }

    method void draw() {
        var int i, ghostBottom;
        var int pupilOffsetX, pupilOffsetY;

        do Screen.setColor(color);
        do Screen.drawCircle(x, y, radius);

        let i = -radius;
        while (~(i > radius)) {
            if (((i + 20) & 1) = 0) {
                let ghostBottom = y + radius - 2;
            } else {
                let ghostBottom = y + radius;
            }
            do Screen.drawLine(x + i, y, x + i, ghostBottom);
            let i = i + 1;
        }
    
        if (dir = 1) { let pupilOffsetX = 0; let pupilOffsetY = -1; }
        if (dir = 2) { let pupilOffsetX = 0; let pupilOffsetY = 1; } 
        if (dir = 3) { let pupilOffsetX = -1; let pupilOffsetY = 0; } 
        if (dir = 4) { let pupilOffsetX = 1; let pupilOffsetY = 0; }
    
        do Screen.setColor(~color);
        do Screen.drawCircle(x - 3, y - 2, 2);
        do Screen.drawCircle(x + 3, y - 2, 2);
    
        do Screen.setColor(color);
        do Screen.drawCircle(x - 3 + pupilOffsetX, y - 2 + pupilOffsetY, 1);
        do Screen.drawCircle(x + 3 + pupilOffsetX, y - 2 + pupilOffsetY, 1);
    
        let spriteDelay = spriteDelay + 1;
        if (spriteDelay = 3) {
            if (sprite = 0) { let adition = 1; }
            if (sprite = 4) { let adition = -1; }
            let sprite = sprite + adition;
            let spriteDelay = 0;
        }
    
        return;
    }

    method int endX() {
        return x + size - 1;
    }
    
    method int endY() {
        return y + size - 1;
    }

    method void dispose() {
        do Memory.deAlloc(this);
        return;
    }
}