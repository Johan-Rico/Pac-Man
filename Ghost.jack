class Ghost {
    field boolean color, firstMove;
    field Map map;
    field PacMan pacman;
    field Score score;
    field int size;
    field int x, y, startX, startY;
    field int dir, nextDir;
    field int nextX, nextY;
    field int sprite, adition;
    field int speed, radius;
    field int previousDir; 
    field int leftLimit, rightLimit;
    field int spriteDelay;

    constructor Ghost new(boolean c, Map m, PacMan p, int xi, int yi) {
        let startX = xi;
        let startY = yi;
        let color = c;
        let speed = 3;
        let radius = 7;
        let map = m;
        let pacman=p;
        let size=12;
        let leftLimit = 1 + radius;
        let rightLimit = 510 - radius;
        do init();
        return this;

    }

    method void init() {
        var int i, ghostBottom;

        let x = startX;
        let y = startY;
        let spriteDelay = 0;
        let previousDir = 2;
        let dir = 2;
        let firstMove = true;
        let nextDir = 2;

        do Screen.setColor(color);
        do Screen.drawCircle(x, y, radius);      
        let i = -radius;
        while (~(i > radius)) {
            if (((i + 20) & 1) = 0) {
              	let ghostBottom = y + radius - 2;
            } else {
              	let ghostBottom = y + radius;
            }
            do Screen.drawLine(x + i, y, x + i, ghostBottom);
            let i = i + 1;
        }
        return;
    }

    method void changeColor(boolean c) {
        let color = c;
        return;
    }
    method void next() {
        var int oldX, oldY;
        var boolean didMove;
        let oldX=x;
        let oldY=y;
        let didMove = advance();
        if (didMove) {
            do Screen.setColor(~color);
    	    do Screen.drawRectangle(oldX - radius, oldY - radius, oldX + radius, oldY + radius + 2);
          	do draw();
        }
        return;
    }

    

    method boolean advance() {
        var int nextX, nextY;
        if (firstMove) {
            let dir = 1;           
            let firstMove = false; 
        }    
        let nextX = getNextX();
        let nextY = getNextY();
        if (checkWalls(nextX, nextY)) {
          	do setNextDirRandom();
          	return false;
        }
        if ((x = nextX) & (y = nextY)) {
          	return false;
        }
        let x = nextX;
        let y = nextY;
        if (x < 9) {
            let x = rightLimit - 1;
        }
        if (x > rightLimit) {
            let x = leftLimit + 1;
        }
        return true;
    }
 
    method boolean checkWalls(int nextX, int nextY) {
        var int nextEndX, nextEndY;
        let nextEndX = nextX + size - 1;
        let nextEndY = nextY + size - 1;
        return map.checkOverlapping(nextX, nextY, radius);
    }

	method boolean checkPacmanCollision() {
		var int pacmanX, pacmanY;
		let pacmanX = pacman.getX();
		let pacmanY = pacman.getY();
		if ((Math.abs(x-pacmanX)<radius) & (Math.abs(y-pacmanY)<radius)) {
			return true;
		}
		return false;
	}
   
  	method void setNextDir() {
    	var int pacmanX, pacmanY;
    	var int diffX, diffY;
    	let pacmanX = pacman.getX();
    	let pacmanY = pacman.getY();
    	let diffX = Math.max(x, pacmanX) - Math.min(x, pacmanX);
    	let diffY = Math.max(y, pacmanY) - Math.min(y, pacmanY);
    	if (~(diffX = 0) & (diffX > diffY)) {
    		if (pacmanX < x) {
    			let dir = 3;
        		return;
      		}
      		let dir = 4;
      		return;
    	}
    	if (pacmanY < y) {
    		let dir = 1;
    		return;
    	}
    	let dir = 2;
    	return;
	}
  
  	method void setNextDirRandom() {
	  	var int i;
	  	let i = Random.randRange(150);
    	if (i < 10) {
			let dir = 1;
    		return;
	  	}
	  	if (i < 20) {
		  	let dir = 2;
      	return;
	  	}
	  	if (i < 25) {
		  	let dir = 3;
      		return;
	  	}
	  	if (i < 150) {
		  	let dir = 4;
      		return;
	  	}
	  	do setNextDir();
    	return;
  	}
  
  	method int getNextX() {
    	var int nextX;
    	let nextX = x;
    	if (dir = 4) {
      		let nextX = x + speed;
    	}
    	if (dir = 3) {
      		let nextX = x - speed;
    	}
    	return nextX;
  	}

  	method int getNextY() {
    	var int nextY;
    	let nextY = y;
    	if (dir = 2) {
      		let nextY = y + speed;
    	}
    	if (dir = 1) {
      		let nextY = y - speed;
    	}
	  	if (nextY > 250) {
      		let nextY = 12;
      		do Screen.setColor(false);
      		do Screen.drawRectangle(x, y, endX(), endY());
    	}
    	if (nextY < 12) {
      		let nextY = 250;
      		do Screen.setColor(false);
      		do Screen.drawRectangle(x, y, endX(), endY());
    	}
    	return nextY;
  	}
 
	method void clearGhost() {
    	do Screen.setColor(~color);
    	do Screen.drawRectangle(x - radius, y - radius, x + radius, y + radius + 2);
    	return;
	}


    method void draw() {
        var int i, ghostBottom;
        var int pupilOffsetX, pupilOffsetY;

        do Screen.setColor(color);
        do Screen.drawCircle(x, y, radius);
    
        let i = -radius;
        while (~(i > radius)) {
            if (((i + 20) & 1) = 0) {
                let ghostBottom = y + radius - 2;
            } else {
                let ghostBottom = y + radius;
            }
            do Screen.drawLine(x + i, y, x + i, ghostBottom);
            let i = i + 1;
        }
    
  
        if (dir = 1) { let pupilOffsetX = 1; let pupilOffsetY = 0; }  //right
        if (dir = 2) { let pupilOffsetX = -1; let pupilOffsetY = 0; } // left
        if (dir = 3) { let pupilOffsetX = 0; let pupilOffsetY = 1; }  // down
        if (dir = 4) { let pupilOffsetX = 0; let pupilOffsetY = -1; } // up
    
   
        do Screen.setColor(~color);
        do Screen.drawCircle(x - 3, y - 2, 2);
        do Screen.drawCircle(x + 3, y - 2, 2);
    

        do Screen.setColor(color);
        do Screen.drawCircle(x - 3 + pupilOffsetX, y - 2 + pupilOffsetY, 1);
        do Screen.drawCircle(x + 3 + pupilOffsetX, y - 2 + pupilOffsetY, 1);
    
        let spriteDelay = spriteDelay + 1;
        if (spriteDelay = 3) {
            if (sprite = 0) { let adition = 1; }
            if (sprite = 4) { let adition = -1; }
            let sprite = sprite + adition;
            let spriteDelay = 0;
        }
    
        return;
    }

    method int endX() {
        return x + size - 1;
    }
    
    method int endY() {
        return y + size - 1;
    }

    method void dispose() {
    	do Memory.deAlloc(this);
        return;
    }   

}