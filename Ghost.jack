class Ghost {
    field boolean color;
    field Map map;
    field PacMan pacman;
    field Score score;
    field Array dirs;
    field int size;
    field int x, y, startX, startY;
    field int dir;
    field int speed, radius;
    field int leftLimit, rightLimit;
    field int time, tm;
    field boolean isPursuer;
    field boolean isVulnerable, isBlinking;
    field boolean isOut;
    field int outX, outY;

    constructor Ghost new(boolean c, Map m, PacMan p, int xi, int yi, boolean pursuer, int t) {
        let dirs = Array.new(4);
        let startX = xi;
        let startY = yi;
        let time = t;
        let tm = t;
        let color = c;
        let speed = 3;
        let radius = 7;
        let outX = 256;
        let outY = 108;
        let map = m;
        let pacman = p;
        let size = radius - 1 * 2;
        let leftLimit = 9;
        let rightLimit = 503;
        let isPursuer = pursuer;
        let isVulnerable = false;

        do init();
        return this;
    }

    method void init() {
        var int i, ghostBottom;
        let x = startX;
        let y = startY;
        let tm = time / Game.getLevel();
        let dir = 3;
        let isOut = false;
        let isBlinking = false;
        return;
    }
    
    method void reset() {
        var int i, ghostBottom;
        let x = 256;
        let y = 144;
        let tm = 50 / Game.getLevel();
        let dir = 3;
        let isOut = false;
        let isBlinking = false;
        return;
    }

    method void changeColor(boolean c) {
        let color = c;
        return;
    }
    
    method void next() {

        do advance();
        do clearGhost();
        if (~(tm < 0)) {
            let tm = tm - 1;
            let dir = 3;
            do draw();
            return;
        }
        if (isOut) {
            let x = getNextX();
            let y = getNextY();
        } else {
            if (~(x = outX)) {
                if ((outX - x) > 0) {
                    let x = x + speed;
                } else {
                    let x = x - speed;
                }
            } else {
                if (y = outY) {
                    let isOut = true;
                } else {
                    let y = y - speed;
                }
            }
        }
        do draw();
        return;
    }

    method void advance() {
        var int d, i;
        var int possibleDirs, oppDir;
        var int pacmanX, pacmanY;
        var int deltaX, deltaY;
        
        let pacmanX = pacman.getX();
        let pacmanY = pacman.getY();
        let deltaX = x - pacmanX;
        let deltaY = y - pacmanY;

        do Random.changeSeed(x*111 + y*195 + pacmanX*215 + pacmanY*331 + Score.getScore());
        do updateDirs();

        let possibleDirs = -1*(dirs[0] + dirs[1] + dirs[2] + dirs[3]);
        let oppDir = getOppositeDir(dir);

        if (((possibleDirs > 1) & (possibleDirs < 4)) & (dirs[oppDir - 1])) {
            let dirs[oppDir - 1] = false;
            let possibleDirs = possibleDirs - 1;
        }

        if (isPursuer | isVulnerable) {
            if ((Math.abs(deltaX) > Math.abs(deltaY)) & (isVulnerable | ~(Random.randRange(2) = 0))) {
                if (tryMove(0, deltaX < 0)) { return; }
                if (tryMove(1, deltaX > 0)) { return; }
                if (tryMove(2, deltaY < 0)) { return; }
                if (tryMove(3, deltaY > 0)) { return; }
            } else {
                if (tryMove(2, deltaY < 0)) { return; }
                if (tryMove(3, deltaY > 0)) { return; }
                if (tryMove(0, deltaX < 0)) { return; }
                if (tryMove(1, deltaX > 0)) { return; }
            }
        }
        let d = Random.randRange(possibleDirs);
        let i = 0;
        while ((i < 4)) {
            if (dirs[i]) {
                if (d = 0) {
                    let dir = i + 1;
                }
                let d = d - 1;
            }
            let i = i + 1;
        }
        return;
       
    }

    method boolean tryMove(int dirIndex, boolean condition) {
        var int oppDir;
        if (isVulnerable) {
            let oppDir = getOppositeDir(dir + 1);
            if (dirs[oppDir - 1] & condition) {
                let dir = oppDir;
                return true;
            }
            return false;
        }
        if (dirs[dirIndex] & condition) {
            let dir = dirIndex + 1;
            return true;
        }
        return false;
    }
    
    method void setVulnerable(boolean v) {
        if (v & ~isVulnerable) {
            let dir = getOppositeDir(dir);
        }
        let isVulnerable = v;
        return;
    }

    method boolean isVulnerable() {
        return isVulnerable;
    }
  
    method boolean checkWalls(int nextX, int nextY) {
        var int nextEndX, nextEndY;
        let nextEndX = nextX + size - 1;
        let nextEndY = nextY + size - 1;
        return (map.checkOverlapping(nextX, nextY, radius) | map.checkDoorOverlaping(nextX, nextY, radius));
    }

    method boolean checkPacmanCollision() {
        var int pacmanX, pacmanY;
        let pacmanX = pacman.getX();
        let pacmanY = pacman.getY();
        if ((Math.abs(x-pacmanX)<radius) & (Math.abs(y-pacmanY)<radius)) {
            return true;
        }
        return false;
    }
   
    method int getNextX() {
        var int nextX;
        let nextX = x;
        if (dir = 1) {
            let nextX = x + speed;
        }
        if (dir = 2) {
            let nextX = x - speed;
        }
        if (nextX < leftLimit) {
            let nextX = rightLimit - 1;
        }
        if (nextX > rightLimit) {
            let nextX = leftLimit + 1;
        }
        return nextX;
    }

    method int getNextY() {
        var int nextY;
        let nextY = y;
        if (dir = 3) {
            let nextY = y + speed;
        }
        if (dir = 4) {
            let nextY = y - speed;
        }

        return nextY;
    }

    method int getOppositeDir(int d) {
        if (d = 1) { return 2; }
        if (d = 2) { return 1; }
        if (d = 3) { return 4; }
        return 3;
    }

    method void updateDirs() {
        let dirs[0] = ~checkWalls(x + speed, y);
        let dirs[1] = ~checkWalls(x - speed, y);
        let dirs[2] = ~checkWalls(x, y + speed);
        let dirs[3] = ~checkWalls(x, y - speed);
        return;
    }
 
    method void clearGhost() {
        do Screen.setColor(~color);
        do Screen.drawRectangle(x - radius, y - radius, x + radius, y + radius + 2);
        return;
    }

    method void setBlinking(boolean b) {
        if (isVulnerable) {
            let isBlinking = b;
        }
        return;
    }

    method void draw() {
        var int i, ghostBottom;
        var int pupilOffsetX, pupilOffsetY;

        do Screen.setColor(color);
        do Screen.drawCircle(x, y, radius);

        let i = -radius;
        while (~(i > radius)) {
            if ((i & 1) = 0) {
                let ghostBottom = y + radius - 2;
            } else {
                let ghostBottom = y + radius;
            }
            do Screen.drawLine(x + i, y + 3, x + i, ghostBottom);
            let i = i + 1;
        }


        do Screen.setColor(~color);
        do Screen.drawPixel(x - 2, y + radius);
        do Screen.drawPixel(x, y + radius);
        do Screen.drawPixel(x + 2, y + radius);
    
        if (isVulnerable) {
            if (isBlinking) { let color = ~color; }
            do Screen.setColor(~color);
            do Screen.drawCircle(x, y, radius - 1);
            do Screen.drawLine(x - radius + 2, y + radius - 3, x + radius - 2, y + radius - 3);
            do Screen.drawLine(x - radius + 3, y + radius - 2, x + radius - 3, y + radius - 2);
            do Screen.setColor(color);
            
            do Screen.drawPixel(x - 4, y + 3);
            do Screen.drawPixel(x - 3, y + 2);
            do Screen.drawPixel(x - 2, y + 2);
            do Screen.drawPixel(x - 1, y + 3);
            do Screen.drawPixel(x, y + 3);
            do Screen.drawPixel(x + 1, y + 3);
            do Screen.drawPixel(x + 2, y + 2);
            do Screen.drawPixel(x + 3, y + 2);
            do Screen.drawPixel(x + 4, y + 3);

            do Screen.drawLine(x - 2, y + radius - 1, x + 2, y + radius - 1);

            let i = (isBlinking);

            do Screen.drawRectangle(x - 3 + i, y - 2  + i, x - 2, y - 1);
            do Screen.drawRectangle(x + 2, y - 2 + i, x + 3 - i, y - 1);
            
            if (isBlinking) { let color = ~color; }
        } else {
            if (dir = 1) { let pupilOffsetX = 1; let pupilOffsetY = 0; }
            if (dir = 3) { let pupilOffsetX = 0; let pupilOffsetY = 1; } 
            if (dir = 2) { let pupilOffsetX = -1; let pupilOffsetY = 0; } 
            if (dir = 4) { let pupilOffsetX = 0; let pupilOffsetY = -1; }
            do Screen.drawCircle(x - 3, y - 2, 2);
            do Screen.drawCircle(x + 3, y - 2, 2);
            do Screen.setColor(color);
            do Screen.drawCircle(x - 3 + pupilOffsetX, y - 2 + pupilOffsetY, 1);
            do Screen.drawCircle(x + 3 + pupilOffsetX, y - 2 + pupilOffsetY, 1);
        }

        return;
    }

    method void dispose() {
        do Memory.deAlloc(this);
        return;
    }
}