class Ghost {
    field boolean color,firstMove;
    field Map map;
    field PacMan pacman;
    field int size;
    field int x, y, dir, nextDir;
    field int nextX, nextY;
    field int sprite, adition;
    field int speed, radius;
    field int previousDir; 
    field int leftLimit, rightLimit;
    field int spriteDelay;

    constructor Ghost new(boolean c, Map m, PacMan p) {
        let color = c;
        let map = m;
        let pacman=p;
        let x = 256;
        let y = 150;
        let radius = 7;
        let size=12;
        let spriteDelay=0;
        let previousDir=2;
        let leftLimit = 1 + radius;
        let rightLimit = 510 - radius;
        let dir = 2;
        let firstMove=true;
        let nextDir = 2;
        let speed = 1;
        do init();
        return this;

    }

    method void init() {
        var int i, ghostBottom;
        do Screen.setColor(color);
        do Screen.drawCircle(x,y,radius);      
        let i = -radius;
        while (~(i > radius)) {
            if (((i + 20) & 1) = 0) {
              let ghostBottom = y + radius - 2;
            } else {
              let ghostBottom = y + radius;
            }
            do Screen.drawLine(x + i, y, x + i, ghostBottom);
            let i = i + 1;
        }
        return;
    }

    method void changeColor(boolean c) {
        let color = c;
        return;
    }
    method void next() {
        var int oldX, oldY;
        var boolean didMove;
        let oldX=x;
        let oldY=y;
        let didMove = advance();
        if (didMove) {
            do clearOld(oldX,oldY);
          do draw();
        }
        return;
    }

      method boolean advance() {
        var int nextX, nextY;
        if (firstMove) {
            let dir = 1;           
            let firstMove = false; 
        }    
        let nextX = getNextX();
        let nextY = getNextY();
        if (checkWalls(nextX, nextY)) {
          do setNextDirRandom();
          return false;
        }
        if ((x = nextX) & (y = nextY)) {
          return false;
        }
        let x = nextX;
        let y = nextY;
        if (x < 9) {
            let x = rightLimit - 1;
        }
        if (x > rightLimit) {
            let x = leftLimit + 1;
        }
        return true;
      }
 
    method boolean checkWalls(int nextX, int nextY) {
        var int nextEndX, nextEndY;
        let nextEndX = nextX + size - 1;
        let nextEndY = nextY + size - 1;
        return map.checkOverlapping(nextX, nextY, radius);
    }
   
  method void setNextDir() {
    var int pacmanX, pacmanY;
    var int diffX, diffY;
    let pacmanX = pacman.getX();
    let pacmanY = pacman.getY();
    let diffX = Math.max(x, pacmanX) - Math.min(x, pacmanX);
    let diffY = Math.max(y, pacmanY) - Math.min(y, pacmanY);
    if (~(diffX = 0) & (diffX > diffY)) {
      if (pacmanX < x) {
        let dir = 3;
        return;
      }
      let dir = 4;
      return;
    }
    if (pacmanY < y) {
      let dir = 1;
      return;
    }
    let dir = 2;
    return;
  }
  
  method void setNextDirRandom() {
	  var int i;
	  let i = Random.randRange(150);
    if (i < 10) {
		let dir = 1;
    return;
	  }
	  if (i < 20) {
		  let dir = 2;
      return;
	  }
	  if (i < 25) {
		  let dir = 3;
      return;
	  }
	  if (i < 150) {
		  let dir = 4;
      return;
	  }
	  do setNextDir();
    return;
  }
  
  method int getNextX() {
    var int nextX;
    let nextX = x;
    if (dir = 4) {
      let nextX = x + speed;
    }
    if (dir = 3) {
      let nextX = x - speed;
    }
    return nextX;
  }

  method int getNextY() {
    var int nextY;
    let nextY = y;
    if (dir = 2) {
      let nextY = y + speed;
    }
    if (dir = 1) {
      let nextY = y - speed;
    }
	  if (nextY > 250) {
      let nextY = 12;
      do Screen.setColor(false);
      do Screen.drawRectangle(x, y, endX(), endY());
    }
    if (nextY < 12) {
      let nextY = 250;
      do Screen.setColor(false);
      do Screen.drawRectangle(x, y, endX(), endY());
    }
    return nextY;
  }
  method void clearOld(int oldX, int oldY) {
    do Screen.setColor(~color);
    do Screen.drawRectangle(oldX - radius, oldY - radius, oldX + radius, oldY + radius + 2); // +2 o +3
    return;
}


    method void draw() {
        var int i, ghostBottom;
        var int pupilOffsetX, pupilOffsetY;
    
      
      
        do Screen.setColor(false);
        do Screen.drawCircle(x, y, radius);
    
        let i = -radius;
        while (~(i > radius)) {
            if (((i + 20) & 1) = 0) {
                let ghostBottom = y + radius - 2;
            } else {
                let ghostBottom = y + radius;
            }
            do Screen.drawLine(x + i, y, x + i, ghostBottom);
            let i = i + 1;
        }
    
  
        if (dir = 1) { let pupilOffsetX = 1; let pupilOffsetY = 0; }  //right
        if (dir = 2) { let pupilOffsetX = -1; let pupilOffsetY = 0; } // left
        if (dir = 3) { let pupilOffsetX = 0; let pupilOffsetY = 1; }  // down
        if (dir = 4) { let pupilOffsetX = 0; let pupilOffsetY = -1; } // up
    
   
        do Screen.setColor(~color);
        do Screen.drawCircle(x - 3, y - 2, 2);
        do Screen.drawCircle(x + 3, y - 2, 2);
    

        do Screen.setColor(color);
        do Screen.drawCircle(x - 3 + pupilOffsetX, y - 2 + pupilOffsetY, 1);
        do Screen.drawCircle(x + 3 + pupilOffsetX, y - 2 + pupilOffsetY, 1);
    
        let spriteDelay = spriteDelay + 1;
        if (spriteDelay = 3) {
            if (sprite = 0) { let adition = 1; }
            if (sprite = 4) { let adition = -1; }
            let sprite = sprite + adition;
            let spriteDelay = 0;
        }
    
        return;
    }
    

    method int deathAnimationFunction(int deathSprite, int i) { 
        if (deathSprite = 0) {  return Math.abs(i);         }
        if (deathSprite = 1) {  return Math.abs(i) + 1 / 2; }
        if (deathSprite = 2) {  return Math.abs(i) + 1 / 3; }
        if (deathSprite = 3) {  return Math.abs(i) / 4;     }
        if (deathSprite = 4) {  return -Math.abs(i) / 4;    }
        if (deathSprite = 5) {  return -Math.abs(i) / 2;    }
        if (deathSprite = 6) {  return -Math.abs(i) / 3;    }
        if (deathSprite = 7) {  return -Math.abs(i);        }
        if (deathSprite = 8) 
        {  return -2*Math.abs(i)*(Math.abs(i) < 5);  }
        return 6*(~(i = 0));
    }

    method void deathAnimation() {
        var int i, deathSprite, func;
        let deathSprite = 0;
        do Screen.setColor(color);
        do Screen.drawCircle(x,y,radius);
        do Screen.setColor(~color);
        while (deathSprite < 10) {
            let i = -7;
            while (~(i > 7)) {
                do Screen.drawLine(x+i, y-radius, x+i, y+1-deathAnimationFunction(deathSprite, i));
                let i = i + 1;
            }
            let deathSprite = deathSprite + 1;
            do Sys.wait(125);
        }
        do Screen.setColor(~color);
        do Screen.drawRectangle(x-radius, y-radius, x+radius, y+radius);
        do Screen.setColor(color);
        do Screen.drawLine(x-4,y,x-7,y);
        do Screen.drawLine(x+4,y,x+7,y);
        do Screen.drawLine(x-3,y-3,x-6,y-6);
        do Screen.drawLine(x+3,y-3,x+6,y-6);
        do Screen.drawLine(x-3,y+3,x-6,y+6);
        do Screen.drawLine(x+3,y+3,x+6,y+6);
        do Screen.drawLine(x-1,y-5,x-3,y-7);
        do Screen.drawLine(x+1,y-5,x+3,y-7);
        do Screen.drawLine(x-1,y+5,x-3,y+7);
        do Screen.drawLine(x+1,y+5,x+3,y+7);
        do Sys.wait(125);
        do Screen.setColor(~color);
        do Screen.drawRectangle(x-radius, y-radius, x+radius, y+radius);
        return;
    }
    method int endX() {
        return x + size - 1;
      }
    
      method int endY() {
        return y + size - 1;
      }

    method void dispose() {
    	do Memory.deAlloc(this);
        return;
    }
    
}